"""
Configuration API endpoints
"""
from fastapi import APIRouter
from pydantic import BaseModel
from typing import Optional
import os
from pathlib import Path

from app.core.config import settings

router = APIRouter()

class ConfigResponse(BaseModel):
    """Configuration response model"""
    base_download_path: str
    audio_extract_mode: str
    max_extraction_workers: int
    max_concurrent_downloads: int
    batch_size: int
    cookies_file: Optional[str]
    use_browser_cookies: bool
    browser_name: str
    needs_setup: bool  # Flag for first-run setup

class ConfigUpdate(BaseModel):
    """Configuration update model"""
    base_download_path: Optional[str] = None
    audio_extract_mode: Optional[str] = None
    max_extraction_workers: Optional[int] = None
    max_concurrent_downloads: Optional[int] = None
    batch_size: Optional[int] = None
    cookies_file: Optional[str] = None
    use_browser_cookies: Optional[bool] = None
    browser_name: Optional[str] = None

def _check_needs_setup() -> bool:
    """Check if initial setup is needed"""
    # Check if .env file exists and has required values
    env_path = Path(__file__).parent.parent.parent / ".env"
    
    if not env_path.exists():
        return True
    
    # Check if BASE_DOWNLOAD_PATH is set to a real path (not default "downloads")
    if settings.BASE_DOWNLOAD_PATH == "downloads":
        return True
    
    # Check if the path exists
    if not os.path.exists(settings.BASE_DOWNLOAD_PATH):
        return True
    
    return False

@router.get("/", response_model=ConfigResponse)
async def get_config():
    """Get current configuration"""
    return ConfigResponse(
        base_download_path=settings.BASE_DOWNLOAD_PATH,
        audio_extract_mode=settings.AUDIO_EXTRACT_MODE,
        max_extraction_workers=settings.MAX_CONCURRENT_EXTRACTIONS,
        max_concurrent_downloads=settings.MAX_CONCURRENT_DOWNLOADS,
        batch_size=settings.BATCH_SIZE,
        cookies_file=settings.COOKIES_FILE,
        use_browser_cookies=settings.USE_BROWSER_COOKIES,
        browser_name=settings.BROWSER_NAME,
        needs_setup=_check_needs_setup()
    )

def _save_to_env(config: ConfigUpdate):
    """Save configuration to .env file"""
    env_path = Path(__file__).parent.parent.parent / ".env"
    
    # Read existing .env content
    env_content = {}
    if env_path.exists():
        with open(env_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_content[key.strip()] = value.strip()
    
    # Update with new values
    if config.base_download_path is not None:
        env_content['BASE_DOWNLOAD_PATH'] = config.base_download_path
    if config.audio_extract_mode is not None:
        env_content['AUDIO_EXTRACT_MODE'] = config.audio_extract_mode
    if config.max_extraction_workers is not None:
        env_content['MAX_CONCURRENT_EXTRACTIONS'] = str(config.max_extraction_workers)
    if config.max_concurrent_downloads is not None:
        env_content['MAX_CONCURRENT_DOWNLOADS'] = str(config.max_concurrent_downloads)
    if config.batch_size is not None:
        env_content['BATCH_SIZE'] = str(config.batch_size)
    if config.cookies_file is not None:
        env_content['COOKIES_FILE'] = config.cookies_file if config.cookies_file else ''
    if config.use_browser_cookies is not None:
        env_content['USE_BROWSER_COOKIES'] = 'true' if config.use_browser_cookies else 'false'
    if config.browser_name is not None:
        env_content['BROWSER_NAME'] = config.browser_name
    
    # Write back to .env
    with open(env_path, 'w', encoding='utf-8') as f:
        f.write("# YouTube Playlist Manager Configuration\n")
        f.write("# Generated by web interface\n\n")
        for key, value in env_content.items():
            f.write(f"{key}={value}\n")

@router.put("/", response_model=ConfigResponse)
async def update_config(config: ConfigUpdate):
    """Update configuration and persist to .env file"""
    
    # Update in-memory settings
    if config.base_download_path is not None:
        settings.BASE_DOWNLOAD_PATH = config.base_download_path
    if config.audio_extract_mode is not None:
        settings.AUDIO_EXTRACT_MODE = config.audio_extract_mode
    if config.max_extraction_workers is not None:
        settings.MAX_CONCURRENT_EXTRACTIONS = config.max_extraction_workers
    if config.max_concurrent_downloads is not None:
        settings.MAX_CONCURRENT_DOWNLOADS = config.max_concurrent_downloads
    if config.batch_size is not None:
        settings.BATCH_SIZE = config.batch_size
    if config.cookies_file is not None:
        settings.COOKIES_FILE = config.cookies_file
    if config.use_browser_cookies is not None:
        settings.USE_BROWSER_COOKIES = config.use_browser_cookies
    if config.browser_name is not None:
        settings.BROWSER_NAME = config.browser_name
    
    # Persist to .env file
    _save_to_env(config)
    
    return ConfigResponse(
        base_download_path=settings.BASE_DOWNLOAD_PATH,
        audio_extract_mode=settings.AUDIO_EXTRACT_MODE,
        max_extraction_workers=settings.MAX_CONCURRENT_EXTRACTIONS,
        max_concurrent_downloads=settings.MAX_CONCURRENT_DOWNLOADS,
        batch_size=settings.BATCH_SIZE,
        cookies_file=settings.COOKIES_FILE,
        use_browser_cookies=settings.USE_BROWSER_COOKIES,
        browser_name=settings.BROWSER_NAME,
        needs_setup=_check_needs_setup()
    )
